\contentsline {figure}{\numberline {1}{\ignorespaces Mica2 sensor and the block diagram.}}{1}{figure.1.1}
\contentsline {subfigure}{\string \numberline {1(a)}{\ignorespaces Mica2 sensor}}{1}{figure.1.1}
\contentsline {subfigure}{\string \numberline {1(b)}{\ignorespaces Mica2 block diagram}}{1}{figure.1.1}
\contentsline {figure}{\numberline {2}{\ignorespaces Imote2 sensor and the block diagram.}}{2}{figure.1.2}
\contentsline {subfigure}{\string \numberline {2(a)}{\ignorespaces Imote2 sensor}}{2}{figure.1.2}
\contentsline {subfigure}{\string \numberline {2(b)}{\ignorespaces Imote2 block diagram}}{2}{figure.1.2}
\contentsline {figure}{\numberline {3}{\ignorespaces Software upgrade in a WSN.}}{3}{figure.1.3}
\contentsline {figure}{\numberline {4}{\ignorespaces Software switch in a WSN.}}{5}{figure.1.4}
\contentsline {figure}{\numberline {5}{\ignorespaces Software update framework overview.}}{6}{figure.1.5}
\contentsline {figure}{\numberline {6}{\ignorespaces Compiler work flow}}{12}{figure.2.6}
\contentsline {figure}{\numberline {7}{\ignorespaces An example of DSP code generation.}}{16}{figure.2.7}
\contentsline {figure}{\numberline {8}{\ignorespaces Basic code distribution protocol (SPIN).}}{19}{figure.2.8}
\contentsline {figure}{\numberline {9}{\ignorespaces The sink-side update-conscious compilation.}}{21}{figure.3.9}
\contentsline {figure}{\numberline {10}{\ignorespaces The sensor-side code update and execution.}}{22}{figure.3.10}
\contentsline {figure}{\numberline {11}{\ignorespaces An example of incremental data allocation.}}{23}{figure.3.11}
\contentsline {figure}{\numberline {12}{\ignorespaces The sensor memory model.}}{24}{figure.3.12}
\contentsline {figure}{\numberline {13}{\ignorespaces An example of data allocation for general purpose applications.}}{27}{figure.3.13}
\contentsline {figure}{\numberline {14}{\ignorespaces An example of register allocation for general purpose applications.}}{29}{figure.3.14}
\contentsline {figure}{\numberline {15}{\ignorespaces The decision variables used in UCC-RA.}}{31}{figure.3.15}
\contentsline {figure}{\numberline {16}{\ignorespaces The objective function used in UCC-RA.}}{36}{figure.3.16}
\contentsline {figure}{\numberline {17}{\ignorespaces The notations used in the UCC-RA objective function.}}{36}{figure.3.17}
\contentsline {figure}{\numberline {18}{\ignorespaces The notations used in the ILP based UCC integration.}}{40}{figure.3.18}
\contentsline {figure}{\numberline {19}{\ignorespaces The objective function used in the ILP based UCC integration.}}{42}{figure.3.19}
\contentsline {figure}{\numberline {20}{\ignorespaces The converted objective function used in the ILP based UCC integration.}}{42}{figure.3.20}
\contentsline {figure}{\numberline {21}{\ignorespaces The notation used in the heuristic based UCC integration.}}{43}{figure.3.21}
\contentsline {figure}{\numberline {22}{\ignorespaces The objective function used in the heuristic based integration.}}{43}{figure.3.22}
\contentsline {figure}{\numberline {23}{\ignorespaces An example of data allocation for DSP applications.}}{45}{figure.3.23}
\contentsline {figure}{\numberline {24}{\ignorespaces An example for the need of UCC data allocation for DSP applications.}}{46}{figure.3.24}
\contentsline {figure}{\numberline {25}{\ignorespaces The update script comparison between CSOA and the update-conscious scheme.}}{47}{figure.3.25}
\contentsline {figure}{\numberline {26}{\ignorespaces An overview of ICSOA-based code update scheme.}}{47}{figure.3.26}
\contentsline {figure}{\numberline {27}{\ignorespaces An example of ICSOA scheme.}}{50}{figure.3.27}
\contentsline {figure}{\numberline {28}{\ignorespaces Patch generation and binary reconstruction.}}{52}{figure.4.28}
\contentsline {figure}{\numberline {29}{\ignorespaces The functional patch script primitives}}{53}{figure.4.29}
\contentsline {figure}{\numberline {30}{\ignorespaces An example of the simple primitives.}}{54}{figure.4.30}
\contentsline {figure}{\numberline {31}{\ignorespaces An example of the {\tt shift} primitive.}}{56}{figure.4.31}
\contentsline {figure}{\numberline {32}{\ignorespaces An example of the {\tt clone} primitive.}}{58}{figure.4.32}
\contentsline {figure}{\numberline {33}{\ignorespaces An example of the {\tt insert\_access} primitive.}}{59}{figure.4.33}
\contentsline {figure}{\numberline {34}{\ignorespaces An example of the interpretation procedure of the {\tt insert\_access} primitive .}}{60}{figure.4.34}
\contentsline {figure}{\numberline {35}{\ignorespaces The data layout patch script primitives.}}{65}{figure.4.35}
\contentsline {figure}{\numberline {36}{\ignorespaces The code construction procedure of the data primitives.}}{67}{figure.4.36}
\contentsline {figure}{\numberline {37}{\ignorespaces Coalesced variable list.}}{68}{figure.4.37}
\contentsline {figure}{\numberline {38}{\ignorespaces The AR in/out value list.}}{69}{figure.4.38}
\contentsline {figure}{\numberline {39}{\ignorespaces Advertise-request-data handshaking protocol in Deluge.}}{72}{figure.5.39}
\contentsline {figure}{\numberline {40}{\ignorespaces An example of software switch in a multi-application WSN (MA-WSN).}}{73}{figure.5.40}
\contentsline {figure}{\numberline {41}{\ignorespaces An example of the application information table (AIT).}}{75}{figure.5.41}
\contentsline {figure}{\numberline {42}{\ignorespaces Gradient-based request routing.}}{77}{figure.5.42}
\contentsline {figure}{\numberline {43}{\ignorespaces Simultaneous code dissemination.}}{79}{figure.5.43}
\contentsline {figure}{\numberline {44}{\ignorespaces Real general purpose application update benchmark.}}{82}{figure.6.44}
\contentsline {figure}{\numberline {45}{\ignorespaces Real DSP application update benchmark. }}{82}{figure.6.45}
\contentsline {figure}{\numberline {46}{\ignorespaces Base benchmarks for general purpose applications.}}{83}{figure.6.46}
\contentsline {figure}{\numberline {47}{\ignorespaces Manually generated general purpose application update benchmark.}}{85}{figure.6.47}
\contentsline {figure}{\numberline {48}{\ignorespaces Manually DSP application update benchmark.}}{86}{figure.6.48}
\contentsline {figure}{\numberline {49}{\ignorespaces Script size comparison between UCC-RA and GCC-RA.}}{89}{figure.6.49}
\contentsline {figure}{\numberline {50}{\ignorespaces Code quality comparison between UCC-RA and GCC-RA.}}{91}{figure.6.50}
\contentsline {figure}{\numberline {51}{\ignorespaces The energy savings per update for general purpose applications.}}{92}{figure.6.51}
\contentsline {figure}{\numberline {52}{\ignorespaces The number of constraints as a function of number of IR instruction.}}{94}{figure.6.52}
\contentsline {figure}{\numberline {53}{\ignorespaces The number of iterations as a function of.}}{94}{figure.6.53}
\contentsline {figure}{\numberline {54}{\ignorespaces The time to solve one iteration as a function of.}}{95}{figure.6.54}
\contentsline {figure}{\numberline {55}{\ignorespaces Script size comparison between UCC-DA and GCC-DA.}}{97}{figure.6.55}
\contentsline {figure}{\numberline {56}{\ignorespaces Worst-case stack size comparison between UCC-DA and GCC-DA.}}{98}{figure.6.56}
\contentsline {figure}{\numberline {57}{\ignorespaces Tradeoff between the worst-case stack size and the instruction updates.}}{99}{figure.6.57}
\contentsline {figure}{\numberline {58}{\ignorespaces Script size comparison between the integrated scheme and the baseline scheme.}}{101}{figure.6.58}
\contentsline {figure}{\numberline {59}{\ignorespaces Script size comparison for real purpose updates.}}{102}{figure.6.59}
\contentsline {figure}{\numberline {60}{\ignorespaces Script size comparison between ICSOA and CSOA ($Num_{addr\_reg} = 1$).}}{104}{figure.6.60}
\contentsline {figure}{\numberline {61}{\ignorespaces Script size comparison ICGOA and CGOA($Num_{addr\_reg} = 2$).}}{105}{figure.6.61}
\contentsline {figure}{\numberline {62}{\ignorespaces Code quality comparison between CSOA and ICSOA.}}{106}{figure.6.62}
\contentsline {figure}{\numberline {63}{\ignorespaces Execution overhead breakdown.}}{106}{figure.6.63}
\contentsline {figure}{\numberline {64}{\ignorespaces Code quality comparison between ICGOA and CGOA.}}{108}{figure.6.64}
\contentsline {figure}{\numberline {65}{\ignorespaces The energy savings for DSP applications.}}{108}{figure.6.65}
\contentsline {figure}{\numberline {66}{\ignorespaces Script size comparison (scattered random new code insertion).}}{110}{figure.6.66}
\contentsline {figure}{\numberline {67}{\ignorespaces Code quality comparison (scattered random new code insertion).}}{111}{figure.6.67}
\contentsline {figure}{\numberline {68}{\ignorespaces Script size comparison between CSOA and ICSOA ($Num_{addr\_reg} = 1$).}}{112}{figure.6.68}
\contentsline {figure}{\numberline {69}{\ignorespaces Script size comparison between CGOA and ICGOA ($Num_{addr\_reg} = 2$).}}{113}{figure.6.69}
\contentsline {figure}{\numberline {70}{\ignorespaces Code quality comparison between CSOA and ICSOA ($Num_{addr\_reg} = 1$).}}{114}{figure.6.70}
\contentsline {figure}{\numberline {71}{\ignorespaces Message overhead.}}{115}{figure.6.71}
\contentsline {figure}{\numberline {72}{\ignorespaces Dissemination time.}}{116}{figure.6.72}
\contentsline {figure}{\numberline {73}{\ignorespaces Dissemination with different number of sources and requesters.}}{117}{figure.6.73}
\contentsline {figure}{\numberline {74}{\ignorespaces Dissemination with uneven source/requester node distribution.}}{117}{figure.6.74}
\contentsline {figure}{\numberline {75}{\ignorespaces Dissemination with different number of pages.}}{119}{figure.6.75}
\contentsline {figure}{\numberline {76}{\ignorespaces Dissemination with Different Cache Sizes.}}{119}{figure.6.76}
