\BOOKMARK [0][]{prelim.0}{TITLE PAGE}{}
\BOOKMARK [0][]{prelim.1}{COMMITTEE MEMBERSHIP PAGE}{}
\BOOKMARK [0][]{prelim.2}{ABSTRACT}{}
\BOOKMARK [0][]{prelim.4}{TABLE OF CONTENTS}{}
\BOOKMARK [0][]{prelim.6}{LIST OF FIGURES}{}\begingroup \makeatletter \prepare@bookmarks 6 \@input {thesis1.lof} \endgroup 
\BOOKMARK [0][]{chapter.1}{1.0 INTRODUCTION}{}
\BOOKMARK [1][]{section.1.1}{1.1 Overview of this research}{chapter.1}
\BOOKMARK [1][]{section.1.2}{1.2 Assumptions}{chapter.1}
\BOOKMARK [1][]{section.1.3}{1.3 Organization of this dissertation}{chapter.1}
\BOOKMARK [0][]{chapter.2}{2.0 BACKGROUND AND RELATED WORK}{}
\BOOKMARK [1][]{section.2.1}{2.1 Software update in WSNs}{chapter.2}
\BOOKMARK [1][]{section.2.2}{2.2 Compiler}{chapter.2}
\BOOKMARK [2][]{subsection.2.2.1}{2.2.1 Register allocation}{section.2.2}
\BOOKMARK [2][]{subsection.2.2.2}{2.2.2 Data allocation}{section.2.2}
\BOOKMARK [1][]{section.2.3}{2.3 Patch generator}{chapter.2}
\BOOKMARK [1][]{section.2.4}{2.4 Distribution protocol}{chapter.2}
\BOOKMARK [0][]{chapter.3}{3.0 \040UPDATE-CONSCIOUS COMPILATION \(UCC\) TECHNIQUES}{}
\BOOKMARK [1][]{section.3.1}{3.1 UCC for general purpose applications}{chapter.3}
\BOOKMARK [2][]{subsection.3.1.1}{3.1.1 UCC data allocation \(UCC-DA\) for general purpose applications}{section.3.1}
\BOOKMARK [3][]{subsubsection.3.1.1.1}{3.1.1.1 Data allocation problem for general purpose applications}{subsection.3.1.1}
\BOOKMARK [3][]{subsubsection.3.1.1.2}{3.1.1.2 UCC data allocation for general purpose applications}{subsection.3.1.1}
\BOOKMARK [2][]{subsection.3.1.2}{3.1.2 UCC register allocation \(UCC-RA\) for general purpose applications}{section.3.1}
\BOOKMARK [3][]{subsubsection.3.1.2.1}{3.1.2.1 Register allocation problem for general purpose applications}{subsection.3.1.2}
\BOOKMARK [3][]{subsubsection.3.1.2.2}{3.1.2.2 UCC register allocation for general purpose applications}{subsection.3.1.2}
\BOOKMARK [2][]{subsection.3.1.3}{3.1.3 Integration of UCC-DA and UCC-RA}{section.3.1}
\BOOKMARK [3][]{subsubsection.3.1.3.1}{3.1.3.1 ILP based integration}{subsection.3.1.3}
\BOOKMARK [3][]{subsubsection.3.1.3.2}{3.1.3.2 Heuristic based integration}{subsection.3.1.3}
\BOOKMARK [1][]{section.3.2}{3.2 UCC for DSP applications}{chapter.3}
\BOOKMARK [2][]{subsection.3.2.1}{3.2.1 Data allocation problem for DSP applications}{section.3.2}
\BOOKMARK [2][]{subsection.3.2.2}{3.2.2 UCC data allocation \(UCC-DA\) for DSP applications}{section.3.2}
\BOOKMARK [3][]{subsubsection.3.2.2.1}{3.2.2.1 Incremental coalescing single offset assignment \(ICSOA\)}{subsection.3.2.2}
\BOOKMARK [2][]{subsection.3.2.3}{3.2.3 Address register allocation and data allocation for DSP applications}{section.3.2}
\BOOKMARK [3][]{subsubsection.3.2.3.1}{3.2.3.1 Incremental coalescing general offset assignment \(ICGOA\)}{subsection.3.2.3}
\BOOKMARK [0][]{chapter.4}{4.0 SOFTWARE DIFFERENTIAL PATCHING}{}
\BOOKMARK [1][]{section.4.1}{4.1 Instruction based patching}{chapter.4}
\BOOKMARK [2][]{subsection.4.1.1}{4.1.1 Simple primitives}{section.4.1}
\BOOKMARK [2][]{subsection.4.1.2}{4.1.2 Advanced primitives}{section.4.1}
\BOOKMARK [3][]{subsubsection.4.1.2.1}{4.1.2.1 shift}{subsection.4.1.2}
\BOOKMARK [3][]{subsubsection.4.1.2.2}{4.1.2.2 clone}{subsection.4.1.2}
\BOOKMARK [3][]{subsubsection.4.1.2.3}{4.1.2.3 insert\137access}{subsection.4.1.2}
\BOOKMARK [2][]{subsection.4.1.3}{4.1.3 Sensor-side interpretation for functional primitives}{section.4.1}
\BOOKMARK [1][]{section.4.2}{4.2 Data based patching}{chapter.4}
\BOOKMARK [2][]{subsection.4.2.1}{4.2.1 Data update primitives}{section.4.2}
\BOOKMARK [3][]{subsubsection.4.2.1.1}{4.2.1.1 copy\137slot}{subsection.4.2.1}
\BOOKMARK [3][]{subsubsection.4.2.1.2}{4.2.1.2 insert\137var}{subsection.4.2.1}
\BOOKMARK [3][]{subsubsection.4.2.1.3}{4.2.1.3 shift\137slot}{subsection.4.2.1}
\BOOKMARK [2][]{subsection.4.2.2}{4.2.2 Sensor-side primitive interpretation}{section.4.2}
\BOOKMARK [3][]{subsubsection.4.2.2.1}{4.2.2.1 Auxiliary data structures}{subsection.4.2.2}
\BOOKMARK [0][]{chapter.5}{5.0 DISTRIBUTION PROTOCOL}{}
\BOOKMARK [1][]{section.5.1}{5.1 Broadcast based code distribution protocol \(Deluge\)}{chapter.5}
\BOOKMARK [1][]{section.5.2}{5.2 Multicast-based code redistribution protocol \(MCP\)}{chapter.5}
\BOOKMARK [2][]{subsection.5.2.1}{5.2.1 The software switch problem in MA-WSNs}{section.5.2}
\BOOKMARK [2][]{subsection.5.2.2}{5.2.2 A multi-cast based code redistribution protocol \(MCP\)}{section.5.2}
\BOOKMARK [2][]{subsection.5.2.3}{5.2.3 ADV message and application information table \(AIT\)}{section.5.2}
\BOOKMARK [2][]{subsection.5.2.4}{5.2.4 Request multicasting}{section.5.2}
\BOOKMARK [2][]{subsection.5.2.5}{5.2.5 Caching}{section.5.2}
\BOOKMARK [1][]{section.5.3}{5.3 Simultaneous code dissemination}{chapter.5}
\BOOKMARK [2][]{subsection.5.3.1}{5.3.1 Protocol augmentation}{section.5.3}
\BOOKMARK [2][]{subsection.5.3.2}{5.3.2 Simultaneous requesting both types of packets}{section.5.3}
\BOOKMARK [1][]{section.5.4}{5.4 Adaptive memory management}{chapter.5}
\BOOKMARK [0][]{chapter.6}{6.0 EXPERIMENTAL RESULTS}{}
\BOOKMARK [1][]{section.6.1}{6.1 Benchmarks}{chapter.6}
\BOOKMARK [2][]{subsection.6.1.1}{6.1.1 Update levels}{section.6.1}
\BOOKMARK [2][]{subsection.6.1.2}{6.1.2 Real update benchmarks \(real-benches\)}{section.6.1}
\BOOKMARK [3][]{subsubsection.6.1.2.1}{6.1.2.1 General purpose application update benchmark}{subsection.6.1.2}
\BOOKMARK [3][]{subsubsection.6.1.2.2}{6.1.2.2 DSP application update benchmark}{subsection.6.1.2}
\BOOKMARK [2][]{subsection.6.1.3}{6.1.3 Manually generated update benchmarks \(man-benches\)}{section.6.1}
\BOOKMARK [3][]{subsubsection.6.1.3.1}{6.1.3.1 General purpose application update benchmark}{subsection.6.1.3}
\BOOKMARK [3][]{subsubsection.6.1.3.2}{6.1.3.2 DSP application update benchmark}{subsection.6.1.3}
\BOOKMARK [2][]{subsection.6.1.4}{6.1.4 Automatically generated update benchmarks \(auto-benches\)}{section.6.1}
\BOOKMARK [3][]{subsubsection.6.1.4.1}{6.1.4.1 General purpose application update benchmark}{subsection.6.1.4}
\BOOKMARK [3][]{subsubsection.6.1.4.2}{6.1.4.2 DSP application update benchmark}{subsection.6.1.4}
\BOOKMARK [3][]{subsubsection.6.1.4.3}{6.1.4.3 Methodology used to generate the auto-benches}{subsection.6.1.4}
\BOOKMARK [1][]{section.6.2}{6.2 Pre-dissemination performance evaluation}{chapter.6}
\BOOKMARK [2][]{subsection.6.2.1}{6.2.1 General purpose software update using UCC-RA}{section.6.2}
\BOOKMARK [3][]{subsubsection.6.2.1.1}{6.2.1.1 Settings}{subsection.6.2.1}
\BOOKMARK [3][]{subsubsection.6.2.1.2}{6.2.1.2 The generate script size}{subsection.6.2.1}
\BOOKMARK [3][]{subsubsection.6.2.1.3}{6.2.1.3 The generated code quality}{subsection.6.2.1}
\BOOKMARK [3][]{subsubsection.6.2.1.4}{6.2.1.4 The energy savings}{subsection.6.2.1}
\BOOKMARK [3][]{subsubsection.6.2.1.5}{6.2.1.5 The problem complexity and compilation time}{subsection.6.2.1}
\BOOKMARK [2][]{subsection.6.2.2}{6.2.2 General purpose software update using UCC-DA}{section.6.2}
\BOOKMARK [3][]{subsubsection.6.2.2.1}{6.2.2.1 Settings}{subsection.6.2.2}
\BOOKMARK [3][]{subsubsection.6.2.2.2}{6.2.2.2 The generated script size}{subsection.6.2.2}
\BOOKMARK [3][]{subsubsection.6.2.2.3}{6.2.2.3 The wasted memory space}{subsection.6.2.2}
\BOOKMARK [3][]{subsubsection.6.2.2.4}{6.2.2.4 Tradeoff between wasted space and binary differences }{subsection.6.2.2}
\BOOKMARK [2][]{subsection.6.2.3}{6.2.3 General purpose software update using the integrated scheme}{section.6.2}
\BOOKMARK [3][]{subsubsection.6.2.3.1}{6.2.3.1 Performance evaluation using man-benches}{subsection.6.2.3}
\BOOKMARK [3][]{subsubsection.6.2.3.2}{6.2.3.2 Performance evaluation using real-benches}{subsection.6.2.3}
\BOOKMARK [2][]{subsection.6.2.4}{6.2.4 DSP software update pre-dissemination}{section.6.2}
\BOOKMARK [3][]{subsubsection.6.2.4.1}{6.2.4.1 Settings}{subsection.6.2.4}
\BOOKMARK [3][]{subsubsection.6.2.4.2}{6.2.4.2 Performance evaluation using man-benches}{subsection.6.2.4}
\BOOKMARK [3][]{subsubsection.6.2.4.3}{6.2.4.3 Performance evaluation using auto-benches}{subsection.6.2.4}
\BOOKMARK [3][]{subsubsection.6.2.4.4}{6.2.4.4 Performance evaluation using real-benches}{subsection.6.2.4}
\BOOKMARK [1][]{section.6.3}{6.3 Patch dissemination performance evaluation}{chapter.6}
\BOOKMARK [2][]{subsection.6.3.1}{6.3.1 Settings}{section.6.3}
\BOOKMARK [2][]{subsection.6.3.2}{6.3.2 Message overhead}{section.6.3}
\BOOKMARK [2][]{subsection.6.3.3}{6.3.3 Completion time}{section.6.3}
\BOOKMARK [2][]{subsection.6.3.4}{6.3.4 Sensitivity to node distribution}{section.6.3}
\BOOKMARK [2][]{subsection.6.3.5}{6.3.5 Sensitivity to application sizes}{section.6.3}
\BOOKMARK [2][]{subsection.6.3.6}{6.3.6 Sensitivity to cache sizes}{section.6.3}
\BOOKMARK [0][]{chapter.7}{7.0 FUTURE DIRECTIONS AND CONCLUSION }{}
\BOOKMARK [1][]{section.7.1}{7.1 Future work}{chapter.7}
\BOOKMARK [2][]{subsection.7.1.1}{7.1.1 Apply to different platforms}{section.7.1}
\BOOKMARK [2][]{subsection.7.1.2}{7.1.2 Approach other update-conscious compilation schemes}{section.7.1}
\BOOKMARK [1][]{section.7.2}{7.2 Conclusion}{chapter.7}
\BOOKMARK [0][]{section*.1}{BIBLIOGRAPHY}{}
